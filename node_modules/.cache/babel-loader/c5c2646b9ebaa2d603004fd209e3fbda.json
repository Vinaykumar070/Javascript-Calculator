{"ast":null,"code":"'use strict';\n\nvar width = 256; // each RC4 output is 0 <= x < 256\nvar chunks = 6; // at least six RC4 outputs for each double\nvar digits = 52; // there are 52 significant digits in a double\nvar pool = []; // pool: entropy pool starts empty\nvar GLOBAL = typeof global === 'undefined' ? window : global;\n\n//\n// The following constants are related to IEEE 754 limits.\n//\nvar startdenom = Math.pow(width, chunks),\n  significance = Math.pow(2, digits),\n  overflow = significance * 2,\n  mask = width - 1;\nvar oldRandom = Math.random;\n\n//\n// seedrandom()\n// This is the seedrandom function described above.\n//\nmodule.exports = function (seed, options) {\n  if (options && options.global === true) {\n    options.global = false;\n    Math.random = module.exports(seed, options);\n    options.global = true;\n    return Math.random;\n  }\n  var use_entropy = options && options.entropy || false;\n  var key = [];\n\n  // Flatten the seed string or build one from local entropy if needed.\n  var shortseed = mixkey(flatten(use_entropy ? [seed, tostring(pool)] : 0 in arguments ? seed : autoseed(), 3), key);\n\n  // Use the seed to initialize an ARC4 generator.\n  var arc4 = new ARC4(key);\n\n  // Mix the randomness into accumulated entropy.\n  mixkey(tostring(arc4.S), pool);\n\n  // Override Math.random\n\n  // This function returns a random double in [0, 1) that contains\n  // randomness in every bit of the mantissa of the IEEE 754 value.\n\n  return function () {\n    // Closure to return a random double:\n    var n = arc4.g(chunks),\n      // Start with a numerator n < 2 ^ 48\n      d = startdenom,\n      //   and denominator d = 2 ^ 48.\n      x = 0; //   and no 'extra last byte'.\n    while (n < significance) {\n      // Fill up all significant digits by\n      n = (n + x) * width; //   shifting numerator and\n      d *= width; //   denominator and generating a\n      x = arc4.g(1); //   new least-significant-byte.\n    }\n    while (n >= overflow) {\n      // To avoid rounding up, before adding\n      n /= 2; //   last byte, shift everything\n      d /= 2; //   right using integer Math until\n      x >>>= 1; //   we have exactly the desired bits.\n    }\n    return (n + x) / d; // Form the number within [0, 1).\n  };\n};\nmodule.exports.resetGlobal = function () {\n  Math.random = oldRandom;\n};\n\n//\n// ARC4\n//\n// An ARC4 implementation.  The constructor takes a key in the form of\n// an array of at most (width) integers that should be 0 <= x < (width).\n//\n// The g(count) method returns a pseudorandom integer that concatenates\n// the next (count) outputs from ARC4.  Its return value is a number x\n// that is in the range 0 <= x < (width ^ count).\n//\n/** @constructor */\nfunction ARC4(key) {\n  var t,\n    keylen = key.length,\n    me = this,\n    i = 0,\n    j = me.i = me.j = 0,\n    s = me.S = [];\n\n  // The empty key [] is treated as [0].\n  if (!keylen) {\n    key = [keylen++];\n  }\n\n  // Set up S using the standard key scheduling algorithm.\n  while (i < width) {\n    s[i] = i++;\n  }\n  for (i = 0; i < width; i++) {\n    s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n    s[j] = t;\n  }\n\n  // The \"g\" method returns the next (count) outputs as one number.\n  (me.g = function (count) {\n    // Using instance members instead of closure state nearly doubles speed.\n    var t,\n      r = 0,\n      i = me.i,\n      j = me.j,\n      s = me.S;\n    while (count--) {\n      t = s[i = mask & i + 1];\n      r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n    }\n    me.i = i;\n    me.j = j;\n    return r;\n    // For robust unpredictability discard an initial batch of values.\n    // See http://www.rsa.com/rsalabs/node.asp?id=2009\n  })(width);\n}\n\n//\n// flatten()\n// Converts an object tree to nested arrays of strings.\n//\nfunction flatten(obj, depth) {\n  var result = [],\n    typ = (typeof obj)[0],\n    prop;\n  if (depth && typ == 'o') {\n    for (prop in obj) {\n      try {\n        result.push(flatten(obj[prop], depth - 1));\n      } catch (e) {}\n    }\n  }\n  return result.length ? result : typ == 's' ? obj : obj + '\\0';\n}\n\n//\n// mixkey()\n// Mixes a string seed into a key that is an array of integers, and\n// returns a shortened string seed that is equivalent to the result key.\n//\nfunction mixkey(seed, key) {\n  var stringseed = seed + '',\n    smear,\n    j = 0;\n  while (j < stringseed.length) {\n    key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n  }\n  return tostring(key);\n}\n\n//\n// autoseed()\n// Returns an object for autoseeding, using window.crypto if available.\n//\n/** @param {Uint8Array=} seed */\nfunction autoseed(seed) {\n  try {\n    GLOBAL.crypto.getRandomValues(seed = new Uint8Array(width));\n    return tostring(seed);\n  } catch (e) {\n    return [+new Date(), GLOBAL, GLOBAL.navigator && GLOBAL.navigator.plugins, GLOBAL.screen, tostring(pool)];\n  }\n}\n\n//\n// tostring()\n// Converts an array of charcodes to a string\n//\nfunction tostring(a) {\n  return String.fromCharCode.apply(0, a);\n}\n\n//\n// When seedrandom.js is loaded, we immediately mix a few bits\n// from the built-in RNG into the entropy pool.  Because we do\n// not want to intefere with determinstic PRNG state later,\n// seedrandom will not call Math.random on its own again after\n// initialization.\n//\nmixkey(Math.random(), pool);","map":null,"metadata":{},"sourceType":"script"}
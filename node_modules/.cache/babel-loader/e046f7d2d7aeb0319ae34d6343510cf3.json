{"ast":null,"code":"'use strict';\n\nvar arraySize = require('../array').size;\nvar isMatrix = require('../collection/isMatrix');\nvar IndexError = require('../../error/IndexError');\n/**\n * Reduce a given matrix or array to a new matrix or\n * array with one less dimension, applying the given\n * callback in the selected dimension.\n * @param {Array | Matrix} mat\n * @param {number} dim\n * @param {Function} callback\n * @return {Array | Matrix} res\n */\n\nmodule.exports = function (mat, dim, callback) {\n  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n  if (dim < 0 || dim >= size.length) {\n    // TODO: would be more clear when throwing a DimensionError here\n    throw new IndexError(dim, size.length);\n  }\n  if (isMatrix(mat)) {\n    return mat.create(_reduce(mat.valueOf(), dim, callback));\n  } else {\n    return _reduce(mat, dim, callback);\n  }\n};\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\n\nfunction _reduce(mat, dim, callback) {\n  var i, ret, val, tran;\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      val = mat[0];\n      for (i = 1; i < mat.length; i++) {\n        val = callback(val, mat[i]);\n      }\n      return val;\n    } else {\n      tran = _switch(mat);\n      ret = [];\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _reduce(tran[i], dim - 1, callback);\n      }\n      return ret;\n    }\n  } else {\n    ret = [];\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _reduce(mat[i], dim - 1, callback);\n    }\n    return ret;\n  }\n}\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\n\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n    ret.push(tmp);\n  }\n  return ret;\n}","map":null,"metadata":{},"sourceType":"script"}